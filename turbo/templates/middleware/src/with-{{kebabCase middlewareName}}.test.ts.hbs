import { describe, suite, test, type TestContext } from "node:test";

// import { flushMicrotasks } from "@qfetch/test-utils";

import { type {{pascalCase middlewareName}}Options, with{{pascalCase middlewareName}} } from "./with-{{kebabCase middlewareName}}.ts";

/* node:coverage disable */
suite("with{{pascalCase middlewareName}} - Unit", () => {

	describe("behavior description from user perspective", () => {
		test("expected observable behavior", async (ctx: TestContext) => {
			// Arrange
			ctx.plan(1);
			const fetchMock = ctx.mock.fn(fetch, async () => new Response("ok"));
			const qfetch = with{{pascalCase middlewareName}}()(fetchMock);

			// Act
			const response = await qfetch("https://example.com");
			const body = await response.text();

			// Assert
			ctx.assert.strictEqual(
				body,
				"ok",
				"assertion message describing expected outcome",
			);
		});

		// For testing multiple variations of the same behavior
		test("behavior with different inputs", async (ctx: TestContext) => {
			// Arrange
			ctx.plan(2); // Number of sub-tests

			await ctx.test("specific value case 1", async (ctx: TestContext) => {
				// Arrange
				ctx.plan(1);
				const fetchMock = ctx.mock.fn(fetch, async () => new Response("ok"));
				const qfetch = with{{pascalCase middlewareName}}()(fetchMock);

				// Act
				const response = await qfetch("https://example.com");
				const body = await response.text();

				// Assert
				ctx.assert.strictEqual(body, "ok", "assertion message");
			});

			await ctx.test("specific value case 2", async (ctx: TestContext) => {
				// Arrange
				ctx.plan(1);
				const fetchMock = ctx.mock.fn(fetch, async () => new Response("ok"));
				const qfetch = with{{pascalCase middlewareName}}()(fetchMock);

				// Act
				const response = await qfetch("https://example.com");
				const body = await response.text();

				// Assert
				ctx.assert.strictEqual(body, "ok", "assertion message");
			});
		});
	});

	// Example: Testing time-based behavior with mock timers
	// describe("time-based behavior", () => {
	// 	test("time-based behavior description", async (ctx: TestContext) => {
	// 		// Arrange
	// 		ctx.plan(2);
	// 		ctx.mock.timers.enable({ apis: ["setTimeout"] });
	// 		const fetchMock = ctx.mock.fn(fetch, async () => new Response("ok"));
	// 		const qfetch = with{{pascalCase middlewareName}}()(fetchMock);
	//
	// 		// Act
	// 		const presponse = qfetch("https://example.com");
	// 		await flushMicrotasks();
	// 		ctx.mock.timers.tick(1000); // Advance time by 1 second
	//
	// 		// Assert
	// 		ctx.assert.strictEqual(
	// 			fetchMock.mock.callCount(),
	// 			1,
	// 			"calls fetch once after delay",
	// 		);
	//
	// 		// Act
	// 		const response = await presponse;
	// 		const body = await response.text();
	//
	// 		// Assert
	// 		ctx.assert.strictEqual(body, "ok", "returns successful response");
	// 	});
	// });
});
