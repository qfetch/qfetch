import { createServer, type Server } from "node:http";
import { describe, it, type TestContext } from "node:test";

import { with{{pascalCase middlewareName}} } from "./with-{{kebabCase middlewareName}}.ts";

interface ServerContext {
	server: Server;
	baseUrl: string;
}

/* node:coverage disable */
describe("with{{pascalCase middlewareName}} middleware - E2E tests", { concurrency: true }, () => {
	/**
	 * Creates an isolated HTTP server for a single test.
	 * Each test gets its own server on a random port to enable concurrent execution.
	 */
	const createTestServer = async (
		ctx: TestContext,
	): Promise<ServerContext> => {
		const server = createServer((req, res) => {
			const url = new URL(req.url || "/", "http://localhost");
			const path = url.pathname;

			// TODO: Add route handlers for your middleware's behavior

			if (path === "/success") {
				res.writeHead(200, { "Content-Type": "application/json" });
				res.end(JSON.stringify({ message: "Success!" }));
				return;
			}

			res.writeHead(404, { "Content-Type": "application/json" });
			res.end(JSON.stringify({ error: "Not Found" }));
		});

		const baseUrl = await new Promise<string>((resolve, reject) => {
			server.listen(0, "127.0.0.1", () => {
				const address = server.address();
				if (address && typeof address === "object") {
					resolve(`http://127.0.0.1:${address.port}`);
				} else {
					reject(new Error("Failed to get server address"));
				}
			});

			server.on("error", reject);
		});

		ctx.after(() => {
			return new Promise<void>((resolve) => {
				server.close(() => resolve());
			});
		});

		return { server, baseUrl };
	};

	// TODO: Add E2E tests for your middleware

	it("should handle successful requests", async (ctx: TestContext) => {
		// arrange
		ctx.plan(1);
		const { baseUrl } = await createTestServer(ctx);
		const qfetch = with{{pascalCase middlewareName}}()(fetch);

		// act
		const response = await qfetch(`${baseUrl}/success`, {
			signal: ctx.signal,
		});

		// assert
		ctx.assert.strictEqual(
			response.status,
			200,
			"Response status should be 200",
		);
	});
});
